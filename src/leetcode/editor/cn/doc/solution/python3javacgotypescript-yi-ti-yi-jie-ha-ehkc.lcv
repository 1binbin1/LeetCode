**æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨æˆ–æ•°ç»„**

æˆ‘ä»¬å¯ä»¥å…ˆç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨æˆ–æ•°ç»„ $s$ è®°å½•æ‰€æœ‰å®çŸ³çš„ç±»å‹ã€‚ç„¶åéå†æ‰€æœ‰çŸ³å¤´ï¼Œå¦‚æœå½“å‰çŸ³å¤´æ˜¯å®çŸ³ï¼Œå°±å°†ç­”æ¡ˆåŠ ä¸€ã€‚

* [sol1-Python3]

```python
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        s = set(jewels)
        return sum(c in s for c in stones)
```

* [sol1-Java]

```java
class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int[] s = new int[128];
        for (char c : jewels.toCharArray()) {
            s[c] = 1;
        }
        int ans = 0;
        for (char c : stones.toCharArray()) {
            ans += s[c];
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int numJewelsInStones(string jewels, string stones) {
        int s[128] = {0};
        for (char c : jewels) s[c] = 1;
        int ans = 0;
        for (char c : stones) ans += s[c];
        return ans;
    }
};
```

* [sol1-Go]

```go
func numJewelsInStones(jewels string, stones string) (ans int) {
	s := [128]int{}
	for _, c := range jewels {
		s[c] = 1
	}
	for _, c := range stones {
		ans += s[c]
	}
	return
}
```

* [sol1-TypeScript]

```ts
function numJewelsInStones(jewels: string, stones: string): number {
    const s = new Set([...jewels]);
    let ans = 0;
    for (const c of stones) {
        s.has(c) && ans++;
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O(m+n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(|\Sigma|)$ï¼Œå…¶ä¸­ $m$ å’Œ $n$ åˆ†åˆ«æ˜¯å­—ç¬¦ä¸² $jewels$ å’Œ $stones$ çš„é•¿åº¦ï¼Œè€Œ $\Sigma$ æ˜¯å­—ç¬¦é›†ï¼Œæœ¬é¢˜ä¸­å­—ç¬¦é›†ä¸ºæ‰€æœ‰å¤§å°å†™è‹±æ–‡å­—æ¯çš„é›†åˆã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
